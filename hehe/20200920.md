# next.js in vercel

ç”±äºå›¢é˜Ÿä»¥ `js/ts` ä¸ºä¸»è¦å¼€å‘è¯­è¨€ï¼Œä¸ºäº†åç»­ç®€åŒ–å’Œè§„èŒƒéƒ¨ç½²æµç¨‹ï¼Œæœ€è¿‘æ‰“ç®— dockerize ä¹‹å‰çš„ next é¡¹ç›®ã€‚å½“ç„¶ï¼Œ`COPY . .` & `RUN yarn` ä¹Ÿèƒ½ç”¨ï¼Œ
ä½†éšç€é¡¹ç›®å‘å±•ï¼Œä¾èµ–å¢å¤š node_modules éšä¹‹è†¨èƒ€ï¼ŒIMAGE SIZE è½»æ¾è¾¾åˆ°æ•°ç™¾å…†ï¼Œä¸å¤ªç†æƒ³ï¼Œé‚£æœ‰äº›ä»€ä¹ˆæ–¹æ³•æ¥ç¼“è§£ï¼Ÿæœ¬æ–‡ç”±æ­¤è€Œæ¥ã€‚

## intro

å…ˆä»‹ç»ä¸€ä¸‹ç°æœ‰çš„ **best practices**

### [multistage](https://docs.docker.com/develop/develop-images/multistage-build/) [builds](https://www.docker.com/blog/advanced-dockerfiles-faster-builds-and-smaller-images-using-buildkit-and-multistage-builds/)

> Multistage builds feature in Dockerfiles enables you to create smaller container images with better caching and smaller security footprint.

multistage å°† build æµç¨‹åˆ’åˆ†ä¸ºå¤šä¸ª stageï¼Œæ¯ä¸ª stage éƒ½**å¯ä»¥**æ˜¯å¹²å‡€çš„ç¯å¢ƒï¼Œé€šè¿‡ `COPY --from=stageName` æ‹·è´å‰é¢æŸä¸ª stage çš„æ–‡ä»¶

```Dockerfile
# install
FROM node:lts-alpine as base
WORKDIR /app
COPY package.json yarn.lock ./
RUN yarn install --frozen-lockfile && yarn build
COPY . .

# build
FROM node:lts-alpine as builder
WORKDIR /app
COPY --from=base /app/package.json /app/yarn.lock ./
RUN yarn install --production --frozen-lockfile
COPY --from=base /app/dist .

# copy
FROM mhart/alpine-node:slim-12
WORKDIR /app
COPY --from=builder /app .

# ...
```

è¿™å¯ä»¥è®©æˆ‘ä»¬ä¸ç”¨å†è€ƒè™‘æ¸…é™¤å„ç§ cache å’Œä¸­é—´æ–‡ä»¶ï¼Œä» stage è·å–ç»“æœæ–‡ä»¶å°±è¡Œäº†ï¼Œå‡å°‘å¿ƒæ™ºè´Ÿæ‹…ï¼Œä¹Ÿå‡å°‘ image å¤§å°ã€‚

(å¼€å¯ [buildkit](https://docs.docker.com/develop/develop-images/build_enhancements/#to-enable-buildkit-builds) åå¯ä»¥åŠ å¿« build é€Ÿåº¦ï¼ŒåŒæ—¶ä¹Ÿä¸ä¼šç”Ÿæˆå¤šä½™çš„ä¸­é—´æ€ image)

(å¾ˆé—æ†¾ï¼Œnode å®˜æ–¹åˆ°ç°åœ¨è¿˜æ²¡æä¾› no-yarn-no-npm-imageï¼Œç¤ºä¾‹ä¸­çš„ [mhart/alpine-node](https://hub.docker.com/r/mhart/alpine-node/) ä»…ä¾›å‚è€ƒ)

### [yarn autoclean](https://classic.yarnpkg.com/en/docs/cli/autoclean/)

> Cleans and removes unnecessary files from package dependencies.

æœ€æ—©çŸ¥é“ç±»ä¼¼çš„æ–¹æ³•ï¼Œæ˜¯åœ¨ tj çš„ [node-prune](https://github.com/tj/node-prune)ï¼ŒåŠŸèƒ½å¾ˆç®€å•ï¼šæ¸…ç† node_modules é‡Œæ‰€æœ‰åœ¨ [blacklist](https://github.com/tj/node-prune/blob/master/internal/prune/prune.go#L17) çš„æ–‡ä»¶ã€‚

æœ¬æ¥æƒ³ç”¨ node-pruneï¼Œä½†æ¯•ç«Ÿéœ€è¦é¢å¤–çš„æ¥å…¥æ­¥éª¤å’Œç¯å¢ƒ (golang)ã€‚åæ¥äº†è§£åˆ° yarn å…¶å®å†…ç½®äº†ç±»ä¼¼åŠŸèƒ½ï¼š**autoclean**

æµ‹è¯•äº†ä¸€ä¸ª api é¡¹ç›®ï¼Œæœ€ç»ˆå‡å°‘ 11mb+ (å¥½è¿‡æ²¡æœ‰)

```
...
yarn autoclean v1.22.4
[1/1] Cleaning modules...
info Removed 3882 files
info Saved 11.09 MB.
Done in 2.92s.
...
```

ä½†æ˜¯æ˜¾ç„¶ï¼Œåˆ é™¤æ— ç”¨æ–‡ä»¶çš„æ–¹å¼ï¼Œç¡®å® **å®‰å…¨** ä½†ä¸ç®—å®Œç¾: esm/cjs/umd/lib/mjs å“ªä¸ªèƒ½åˆ ï¼Œè¿™äº›éƒ½åªèƒ½ _è¯»_ äº†ä»£ç æ‰æ™“å¾—ã€‚

å†æƒ³æƒ³

## vercel

next.js æ—¢ç„¶ç”± vercel å›¢é˜Ÿå¼€å‘ï¼Œé‚£æ˜¯ä¸æ˜¯å¯ä»¥ä»å…¶å¼€æºé¡¹ç›®ä¸­ï¼Œæ‰¾åˆ°åˆé€‚çš„ä¼˜åŒ–æ–¹æ¡ˆ

### [ncc](https://github.com/vercel/ncc)

> Simple CLI for compiling a Node.js module into a single file, together with all its dependencies, gcc-style.

é¦–å…ˆè¿›å…¥è§†é‡çš„æ˜¯ [@vercel/ncc](https://github.com/vercel/ncc)ï¼Œå…¶é€šè¿‡ webpack å°† node é¡¹ç›® (js/jsx/ts) æ‰“åŒ…ä¸º **single file** çš„æ–¹å¼ï¼Œå‰ç«¯åŒå­¦æ—©å°±ä¹ ä»¥ä¸ºå¸¸ï¼Œ
ä½†ä¸€ç›´ä»¥æ¥ï¼ŒæœåŠ¡ç«¯ç«¯å¯¹æ­¤é²œæœ‰å€Ÿé‰´ï¼Œä¸€æ–¹é¢ï¼ŒæœåŠ¡ç«¯å¯¹äºåŒ…å¤§å°å¹¶ä¸æ•æ„Ÿï¼Œç¡¬ç›˜ä¸å€¼é’±ï¼Œä¼ ç»Ÿçš„ `npm install` + `pm2`ï¼Œé…åˆæœåŠ¡å™¨é•œåƒç­‰æ–¹å¼ï¼Œä¹Ÿèƒ½å®Œæˆçº¿ä¸Šéƒ¨ç½²ï¼ˆåˆä¸æ˜¯ä¸èƒ½ç”¨.jpgï¼‰ã€‚

ä½†åœ¨æ–°çš„äº‘æœåŠ¡æ¶æ„ä¸‹ï¼Œä¸è®ºæ˜¯åŸºäº docker è¿˜æ˜¯ JAMStack/serverlessï¼Œåˆ†å‘åŒ…çš„ä½“ç§¯å¯¹éƒ¨ç½²æ•ˆç‡æ‰€äº§ç”Ÿçš„å½±å“ï¼Œå·²ç»ä¸å†æ˜¯å¾®ä¸è¶³é“äº† (äº‹å®ä¸Šï¼Œäº‘å¹³å°å¯¹ç”¨æˆ·çš„èµ„æºå¤§å°ä¹Ÿå­˜åœ¨ç€é™åˆ¶ï¼Œèµ„æºå¤§å°ä¹Ÿå†³å®šäº†å†·å¯åŠ¨çš„æ—¶é—´)ã€‚

### [nft](https://github.com/vercel/nft) (node-file-trace)

åœ¨å¤šä¸ª next.js çš„ issues/discussions ä¸‹ï¼Œçœ‹åˆ°ç±»ä¼¼è¿™æ ·çš„å®˜æ–¹å›å¤ï¼š

> We used to use ncc for Node and Next.js deployments but we switched to node-file-trace instead.

æ„å‘³ç€ï¼Œç°åœ¨åœ¨ vercel éƒ¨ç½² nextï¼Œå¹³å°å·²ç»è½¬è€Œä½¿ç”¨äº† [@vercel/ntf](https://github.com/vercel/nft) ï¼Œè¿™æ˜¯ä¸ªä»€ä¹ˆä¸œè¥¿ï¼Ÿ

> This package is used in @vercel/node and @vercel/next to determine exactly which files (including node_modules) are necessary for the application runtime.

> This is similar to @vercel/ncc except there is no bundling performed and therefore no reliance on webpack. This achieves the same tree-shaking benefits without moving any assets or binaries.

å’Œ ncc ç±»ä¼¼ï¼Œ@vercel/nft åˆ™æ˜¯é€šè¿‡ [acron](https://github.com/acornjs/acorn) å¾—åˆ°ä»£ç æ‰§è¡Œæ‰€éœ€çš„ä¾èµ–ï¼ŒæŸç§ç¨‹åº¦éƒ½å®ç°äº† tree-shakingï¼Œ
ä½†ä¸åŒçš„æ˜¯ï¼Œncc æ˜¯é€šè¿‡ webpack çš„èƒ½åŠ›å°†é¡¹ç›®æ‰“åŒ…ï¼›@vercel/nft åˆ™æ²¡æœ‰æ‰“åŒ…ï¼Œæœ€ç»ˆäº§ç‰©æ˜¯ fileListï¼Œè€Œå…·ä½“å¯¹åˆ—è¡¨ä½œå‡ºä½•ç§å¤„ç†ï¼Œåˆ™äº¤ç”±ç”¨æˆ·é€‰æ‹©ã€‚

[ntf cli](https://github.com/vercel/nft/blob/master/src/cli.ts#L33) å°±æä¾›äº†ä¸€ä¸ªä¾‹å­:

```js
const { fileList, esmFileList, warnings } = await nodeFileTrace(files, opts);
const allFiles = fileList.concat(esmFileList);
const stdout = [];

if (action === 'print') {
  // ... print action ...
} else if (action === 'build') {
  rimraf.sync(join(cwd, outputDir));
  for (const f of allFiles) {
    const src = join(cwd, f);
    const dest = join(cwd, outputDir, f);
    const dir = dirname(dest);
    await mkdir(dir, { recursive: true });
    await copyFile(src, dest);
  }
}
```

æ‰§è¡Œ `npx nft build app.js`

```js
// app.js
const {ApolloClient} = require('@apollo/client')
console.log(ApolloClient)
```

```shell
-> du -sh dist/node_modules
464K	dist/node_modules
```

æœ€ç»ˆå°† copy nodeFileTrace äº§å‡ºçš„æ‰€æœ‰æ–‡ä»¶åˆ° dist ç›®å½•ï¼Œæ²¡æœ‰ bundle æµç¨‹ï¼Œå°±æ˜¯çº¯çº¯çš„ copy

### why nft

é‚£è¿™æ ·åšçš„ç›®çš„æ˜¯ä»€ä¹ˆï¼Ÿçœ‹èµ·æ¥ä»å¾—åˆ° fileList åˆ°æ‰“åŒ… single file å®Œå…¨æ˜¯é¡ºç†æˆç« çš„äº‹ï¼Œè€Œ vercel å´æ”¾å¼ƒåè€…ï¼Œå¼€å§‹ä¿ç•™èµ·ç›®å½•ç»“æ„æ¥äº†ï¼Ÿ

å…ˆçœ‹çœ‹æ‰“åŒ…æˆå•æ–‡ä»¶æœ‰ä»€ä¹ˆé—®é¢˜ï¼š

- ä¸èƒ½ diff ä¾èµ–ï¼Œæ¯æ¬¡éƒ¨ç½²éƒ½æ˜¯æ•´ä¸ªé¡¹ç›®ï¼ˆå“ªæ€•åªæœ‰ä¸€ä¸ªæ–‡ä»¶ï¼‰ï¼Œå¯¹äºä¾èµ–çš„å˜åŒ–çŸ¥ä¹‹ç”šå°‘
- å¯¹äºçº¦å®šå¤§äºé…ç½®çš„åº”ç”¨ï¼Œæ”¯æŒå›°éš¾ (next.js çš„ api pages ç›®å½•ï¼Œgraphql-tools çš„ mergeResolvers ...)
- webpack ä¸æ˜¯ä¸‡èƒ½çš„ï¼Œéœ€è¦å¯¹ç‰¹æ®Šçš„åŒ…åšå…¼å®¹ (æ‰‹åŠ¨æ‹·è´ bull çš„ [lua æ–‡ä»¶](https://github.com/OptimalBits/bull/tree/develop/lib/commands) ...)

é‚£å’Œæˆ‘å‘¨æ ‘äººæœ‰ä»€ä¹ˆå…³ç³»ï¼š

- æ”¯æŒå¤šè¾“å…¥æ–‡ä»¶ï¼Œè§£å†³çº¦å®šå¤§äºé…ç½® (`npx nft build src/app.ts src/modules/a.resolver.ts`)
- æ›´é«˜çš„æ‰§è¡Œæ•ˆç‡ï¼Œæ²¡æœ‰ webpack çš„å±‚å±‚ wrapperï¼Œæ²¡æœ‰é­”æ³•
- æ›´çµæ´»çš„æ§åˆ¶ï¼Œæ˜¯ tar åŒ…å‘å¸ƒï¼Œè¿˜æ˜¯åˆ›å»º Lambda Layerï¼Œè¿˜æ˜¯å…ˆå’Œä¸Šä¸€ä¸ªç‰ˆæœ¬çš„ fileList åš diff å†çœ‹æƒ…å†µå¤„ç†ï¼Œèƒ½åšçš„äº‹æƒ…å¾ˆå¤šï¼Œ[å¾ˆå¤šå¾ˆå¤š](https://www.youtube.com/watch?v=pf0rS-egxhU)ã€‚

é‚£æˆ‘è¦æ äº†ï¼Œå¦‚æœç”¨ ncc å°†æ‰€æœ‰ dependencies æ‰“åŒ…ä¸€ä¸ªåš lambda layerï¼Œè€Œç”¨æˆ·ä»£ç å†æ‰“ä¸ªåŒ…è¡Œä¸è¡Œï¼Ÿ

ç­”ï¼šå¯ä»¥æ˜¯å¯ä»¥ï¼Œä¸è¿‡è¿™å°±æ”¾å¼ƒäº† tree-shakingï¼Œæ¯•ç«Ÿ **ç†è§£ä»£ç ** æ˜¯ä¼˜åŒ–çš„ç»ˆç‚¹ã€‚
å°±å¥½æ¯”å½“åˆåªè¦ä¸€ä¸ª cdn åœ°å€ï¼Œjquery/lodash æ‰€æœ‰æ–¹æ³•éšå¿ƒç”¨ï¼Œåˆ°å¦‚ä»Šï¼Œæ¯ä¸ªåº“/æ¡†æ¶éƒ½è¦å°å¿ƒç¿¼ç¿¼ä¿è¯ tree-shakable (lighthouse è¿™ç©æ„å„¿å¯æ€•å“Ÿ)ã€‚

## vercel/vercel

ä¼—æ‰€å‘¨çŸ¥ï¼Œvercel æ˜¯ next.js èƒŒåçš„ ğŸ‘©ï¼Œé…ç½®å¥½ GitHub/GitLab/.. ä¹‹ååªè¦ä¸€ä¸ª `git push`ï¼Œå‰©ä¸‹çš„æ‰“åŒ…å‘å¸ƒä¸Šçº¿éƒ½ç”± vercel å®Œæˆã€‚è¿™ä¸ª "å®Œæˆ" èƒŒåï¼Œå°±æœ‰ vercel runtime çš„å‚ä¸ã€‚

é‚£ vercel runtime æœ‰ä»€ä¹ˆå¥½ç‚¹å­ï¼Ÿ

### no dockerfile

> rauchg: In short, the usage of Docker containers creates an opaque box that doesn't allow us to fully take advantage of modern cloud primitives.

æœç´¢ä¹‹åå¾—çŸ¥ï¼Œvercel (ä¹‹å‰å« zeit/now) æ˜¯ä» v2.0 å¼€å§‹å–æ¶ˆçš„ Dockerfile éƒ¨ç½²æ–¹å¼ï¼Œç›®çš„æ˜¯ä¸ºäº†å¯¹é¡¹ç›®èƒ½æœ‰æ›´å¥½çš„æ§åˆ¶ï¼Œé«˜æ•ˆçš„åˆ©ç”¨äº‘ç«¯ (aws/gcp) èµ„æº (lambda/cdn)ã€‚

è®²å¾—é€š

è™½ç„¶å’Œæœ¬æ–‡åˆè¡·ç•¥æœ‰ç›¸èƒŒï¼Œä¸è¿‡ä¸è¦ç´§ï¼Œæ®Šé€”åŒå½’ï¼Œå…ˆçœ‹çœ‹ç”¨äº† @vercel/nft çš„ [@vercel/next](https://github.com/vercel/vercel/blob/master/packages/now-next/) (next runtime for vercel)ï¼Œéƒ½åšäº†äº›ä»€ä¹ˆ

### runtime

ç­‰ç­‰ç­‰ç­‰ï¼Œè¯´åˆ° vercel runtimeï¼Œé¡ºä¾¿å¾—æä¸€å¥ï¼Œäº‹å®ä¸Š vercel ä¸å…‰æ”¯æŒ node å’Œ nextï¼Œä¹Ÿæ”¯æŒå…¶ä»–è¯­è¨€ (go/python/ruby ...)ï¼Œé•¿è¯çŸ­è¯´ï¼šåªè¦èƒ½åœ¨ lambda ä¸Šè·‘ï¼Œç®¡ä½ ä»€ä¹ˆè¯­è¨€ã€‚

vercel å¯¹å…¶å¹³å°çš„ runtime å®šä¹‰æ˜¯ï¼šç¬¦åˆ Runtime interface çš„ node package ([DEVELOPING_A_RUNTIME.md](https://github.com/vercel/vercel/blob/master/DEVELOPING_A_RUNTIME.md))ï¼š

```ts
interface Runtime {
  version: number;
  build: (options: BuildOptions) => Promise<BuildResult>;
  analyze?: (options: AnalyzeOptions) => Promise<string>;
  prepareCache?: (options: PrepareCacheOptions) => Promise<CacheOutputs>;
  shouldServe?: (options: ShouldServeOptions) => Promise<boolean>;
  startDevServer?: (
    options: StartDevServerOptions
  ) => Promise<StartDevServerResult>;
}
```

è¿™é‡Œæœ€é‡è¦çš„å°±æ˜¯ `build: (options: BuildOptions) => Promise<BuildResult>`ï¼Œè¾“å…¥ä»£ç æ–‡ä»¶åˆ—è¡¨å’Œä¸€äº›é…ç½®ä¿¡æ¯ï¼Œè¾“å‡º [Files](https://github.com/vercel/vercel/blob/19ac74d59ebf8fd6388090051894b695f1fc9504/packages/now-build-utils/src/types.ts#L19)/routes ç­‰ä¿¡æ¯ã€‚

æœ€ç»ˆç”± vercel è°ƒç”¨äº‘æœåŠ¡å•†çš„æ¥å£å®Œæˆéƒ¨ç½² (lambda@edge)

### @vercel/next

é‚£ next runtime æœ‰ä»€ä¹ˆç‰¹åˆ«çš„åœ°æ–¹ï¼Ÿ

å…¶ä¸»è¦ä»£ç ä½äº `now-next/src/index.ts`ï¼ŒæŒ‰ runtime è¦æ±‚ï¼Œexport build + prepareCacheï¼Œå…¶ä»£ç æ‰§è¡Œæµç¨‹å¦‚ä¸‹:

```shell
// è¿™é‡Œåº”è¯¥æœ‰ä¸€å¼ æµç¨‹å›¾ï¼Œæ”¹å¤©å†è¡¥ï¼Œå­˜ä¸ªæ¡£
// å¤šè¯´ä¸€å¥ï¼Œindex.ts å¿«ä¸¤åƒè¡Œä»£ç ï¼Œåˆ°å¤„ if elseï¼Œæ€ä¹ˆä¹Ÿä¸ç»™æ•´ç†ä¸€ä¸‹ï¼Œæ°”äºº
```

ä¸‹é¢æ˜¯ @vercel/next é‡Œç”¨åˆ° nft çš„åœ°æ–¹:

```ts
// æ”¶é›† pages å†…ä¾èµ–çš„æ–‡ä»¶åˆ—è¡¨
const { fileList, reasons: nonApiReasons } = await nodeFileTrace(
  nonApiPages,
  {
    base: baseDir,
    processCwd: entryPath,
  }
);
```

nft é™¤äº†è¿”å› fileListï¼Œè¿˜æœ‰æ¯ä¸ªæ–‡ä»¶è¢«å¼•ç”¨çš„åŸå›  ([reasons object](https://github.com/vercel/nft/blob/master/readme.md#reasons))
è¿™é‡Œè¿‡æ»¤äº†åˆå§‹æ–‡ä»¶ (reason.type === 'initial')

```ts
const collectTracedFiles = (
  reasons: NodeFileTraceReasons,
  files: { [filePath: string]: FileFsRef }
) => async (file: string) => {
  const reason = reasons[file];
  if (reason && reason.type === 'initial') {
    // Initial files are manually added to the lambda later
    return;
  }

  // ...
  files[file] = new FileFsRef(/* ... */);
};

// æ”¶é›† tracedFiles
await Promise.all(
  fileList.map(collectTracedFiles(nonApiReasons, tracedFiles))
);

// pseudoLayer: { [fileName: string]: PseudoFile }
// PseudoFile é‡Œæœ‰æ–‡ä»¶ buffer
let { pseudoLayer, pseudoLayerBytes } = await createPseudoLayer(tracedFiles);

// createLambda
/* for loop */
  const lambdas: { [key: string]: Lambda } = {};
  lambdas[group.lambdaIdentifier] = createLambdaFromPseudoLayers({
    files: {...launcherFiles},
    layers: [...pseudoLayers, ...pageLayers],
    handler: path.join(
      path.relative(baseDir, entryPath),
      'now__launcher.launcher'
    ),
  })
/* end */
```

æœ€åè¿”å›è¿™äº›ç©æ„ä¾› vercel éƒ¨ç½²

```ts
return {
  output: {
    ...publicDirectoryFiles,
    ...lambdas,
    // Prerenders may override Lambdas -- this is an intentional behavior.
    ...prerenders,
    ...staticPages,
    ...staticFiles,
    ...staticDirectoryFiles,
  },
  routes: {
    // ...
  },
}
```

ä¸å¾—ä¸è¯´ï¼Œæœ‰ç‚¹ä¸œè¥¿ï¼Œæ€»ç»“ä¸‹æ¥ï¼Œvercel/next ä¼šæŠŠ `pages/**/*` çš„ pages ç»„æˆ lambdaGroup (åªè¦å°äº lambdaByteLimit)ï¼Œ
æœ€ç»ˆå°† lambdas å’Œä¸€äº›é™æ€æ–‡ä»¶ä½œä¸º output è¿”å›ç»™ vercelï¼Œvercel å®Œæˆæ¥ä¸‹æ¥çš„éƒ¨ç½²ï¼Œè¿™éƒ¨åˆ†æš‚æ—¶æ²¡æœ‰çœ‹åˆ°å…¬å¼€èµ„æ–™ã€‚

```ts
export class Lambda {
  public type: 'Lambda';
  public zipBuffer: Buffer;
  public handler: string;
  public runtime: string;
  public memory?: number;
  public maxDuration?: number;
  public environment: Environment;

  constructor({
    zipBuffer,
    handler,
    runtime,
    maxDuration,
    memory,
    environment,
  }: LambdaOptions) {
    this.type = 'Lambda';
    this.zipBuffer = zipBuffer;
    this.handler = handler;
    this.runtime = runtime;
    this.memory = memory;
    this.maxDuration = maxDuration;
    this.environment = environment;
  }
}
```

é‚£æ‹¿åˆ° output å’Œ routes ç­‰æ•°æ®ä¹‹åï¼Œæ€ä¹ˆåšï¼Œ**å¯ä»¥** æ€ä¹ˆåšï¼Ÿè¿™ä¼¼ä¹å·²ç»ä¸åœ¨æœ¬æ–‡è®¨è®ºçš„èŒƒå›´ã€‚

## callback

å›åˆ°æ­£é¢˜ï¼Œæˆ‘ä»¬æ¯•ç«Ÿæ˜¯æƒ³è¿½æ±‚å°ä½“ç§¯ï¼Œææ¥æå»è¿™ä¹ˆå¤šï¼Œæœ€åä»€ä¹ˆç»“è®ºå•Šï¼Ÿ

å†è¯´å§

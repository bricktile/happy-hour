- date: 20200702
- author: xiaojingzhao

## Plan

- 你不知道的 js 下册 第七章 元编程

## Notes

### 函数名称

函数具有 name 属性：

```js
var abc = function () {
  //
};
abc.name; // "abc"

// 匿名函数
(function () {}.name); // ""

// generator
(function* () {}.name); // ""

class Awesome {
  contructor() {} // Awesome
  funny() {} // funny
}

var o = {
  foo() {}, // foo
  *bar() {}, // bar
  baz: () => {}, // baz
  bam: function () {}, // bam
  get qux() {
    // get qux
    return "aa";
  },
  set fuz(val) {}, // set  fux
  ["b" + "iz"]: function () {}, // biz
  [Symbol("buz")]: function () {}, // Symbol("buz")
};

// bind
var x = o.foo.bind(o); // bound foo
(function () {}.bind(o)); // bound

// esm
export default function () {} // default

// 通过 new 关键字
var y = new Function(); // anonymous
var GeneratorFuntion = function* () {}.__proto__.constructor;
var z = new GerneratorFuntion(); // anonymous
```

### new.target

在构造器调用中，new 会形成一个虚拟上下文

```js
class Parent {
  constructor() {
    if (new.target === "Parent") {
      console.log("111");
    } else {
      console.log("222");
    }
  }
}
class Child extends Parent {}
var a = new Parent(); // 111
var b = new Child(); // 222
```

### Symbol 公开符号

- Symbol.iterator 一个构造迭代器的方法。可以自定义来覆盖原有的迭代器
- Symbol.toString + Symbol.hasInstance

Symbol.toString 指定了在[Object xxx] 字符串化时使用的字符串值

```js
function Foo() {}
Foo.toString(); // function Foo() {}
```

Symbol.hasInstance 是构造器函数上的一个方法，接受实例对象值，通过返回 true 或者 false 来指示这个值是否可以成为一个实例

```js
a = new Foo();
a instanceof Foo; // 可以覆盖原生 instanceof
```

- Symbol.species 生成新实例时，内置方法使用哪一个构造器

## More
